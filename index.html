<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess vs AI</title>
    <style>
        /* ... (keep existing styles unchanged) ... */
    </style>
</head>
<body>
    <div id="game-container">
        <h1>Chess vs AI</h1>
        <div id="chessboard"></div>
        <div id="status"></div>
        <button onclick="restartGame()">Restart Game</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script>
        const boardElement = document.getElementById('chessboard');
        const statusElement = document.getElementById('status');
        const chess = new Chess();
        const stockfish = new Worker('https://unpkg.com/stockfish-js@0.12.0/stockfish.js');
        let selectedSquare = null;
        let validMoves = [];
        let aiThinking = false;

        // Set AI difficulty (skill level 0-20)
        const aiSkillLevel = 15;

        // Initialize Stockfish
        stockfish.postMessage('uci');
        stockfish.postMessage(`setoption name Skill Level value ${aiSkillLevel}`);

        function initializeBoard() {
            boardElement.innerHTML = '';
            const board = chess.board();
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.position = toAlgebraic(row, col);
                    const piece = board[row][col];
                    if (piece) {
                        square.textContent = getPieceSymbol(piece);
                    }
                    square.addEventListener('click', () => handleSquareClick(square.dataset.position));
                    boardElement.appendChild(square);
                }
            }
            highlightValidMoves();
            updateStatus();
        }

        function getPieceSymbol(piece) {
            const symbols = {
                'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚',
                'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔'
            };
            return symbols[piece.type.toUpperCase()];
        }

        function handleSquareClick(position) {
            if (aiThinking || chess.game_over()) return;

            // Human player's turn (White)
            if (chess.turn() === 'w') {
                if (selectedSquare === position) {
                    clearSelection();
                    return;
                }

                if (selectedSquare) {
                    tryMove(selectedSquare, position);
                } else {
                    selectSquare(position);
                }
            }
        }

        function selectSquare(position) {
            const moves = chess.moves({ square: position, verbose: true });
            if (moves.length > 0 && chess.get(position).color === 'w') {
                selectedSquare = position;
                validMoves = moves.map(m => m.to);
                highlightValidMoves();
            }
        }

        function tryMove(from, to) {
            const move = chess.move({ from, to, promotion: 'q' });
            if (move) {
                clearSelection();
                initializeBoard();
                if (!chess.game_over()) {
                    aiThinking = true;
                    requestAiMove();
                }
            } else {
                clearSelection();
                selectSquare(to);
            }
        }

        function requestAiMove() {
            stockfish.postMessage(`position fen ${chess.fen()}`);
            stockfish.postMessage('go depth 10');
        }

        stockfish.onmessage = (event) => {
            const message = event.data;
            if (message.startsWith('bestmove')) {
                const bestMove = message.split(' ')[1];
                if (bestMove && bestMove !== 'null') {
                    chess.move(bestMove);
                    initializeBoard();
                    aiThinking = false;
                }
            }
        };

        function highlightValidMoves() {
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('selected', 'valid-move');
                if (square.dataset.position === selectedSquare) {
                    square.classList.add('selected');
                }
                if (validMoves.includes(square.dataset.position)) {
                    square.classList.add('valid-move');
                }
            });
        }

        function updateStatus() {
            let status = '';
            if (chess.in_checkmate()) {
                status = `Checkmate! ${chess.turn() === 'w' ? 'Black' : 'White'} wins!`;
            } else if (chess.in_draw()) {
                status = 'Draw!';
            } else if (chess.in_check()) {
                status = `Check! ${chess.turn() === 'w' ? 'White' : 'Black'}'s turn`;
            } else {
                status = `${chess.turn() === 'w' ? 'White' : 'Black'}'s turn`;
            }
            statusElement.textContent = status;
        }

        function toAlgebraic(row, col) {
            const files = 'abcdefgh';
            return files[col] + (8 - row);
        }

        function clearSelection() {
            selectedSquare = null;
            validMoves = [];
            highlightValidMoves();
        }

        function restartGame() {
            chess.reset();
            aiThinking = false;
            clearSelection();
            initializeBoard();
        }

        initializeBoard();
    </script>
</body>
</html>
