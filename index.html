<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess vs AI (Super Enhanced v6)</title>
    <style>
        body {
            background-color: #1e2a44;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        .game-container {
            text-align: center;
            padding: 20px;
        }
        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 0;
            margin: 0 auto;
            border: 2px solid #fff;
        }
        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            position: relative;
            font-family: "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif;
        }
        .light { background-color: #ebecd0; }
        .dark { background-color: #779556; }
        .selected { background-color: #ffeb3b !important; }
        .valid-move { background-color: #baca44 !important; }
        .notation {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            color: #000;
            display: none;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            background-color: #5c6bc0;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover { background-color: #4a5aa8; }
        #status {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            font-size: 18px;
        }
        #difficulty-select, #side-select {
            margin-top: 10px;
            padding: 5px;
            font-size: 16px;
        }
        #error-message {
            color: #ff4444;
            margin-top: 10px;
            font-size: 16px;
            display: none;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #rating-display {
            color: white;
            margin-top: 10px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="status">White to move</div>
        <div id="chessboard"></div>
        <div class="controls">
            <button onclick="newGame()">NEW GAME</button>
            <button onclick="undoMove()">UNDO MOVE</button>
            <button onclick="toggleNotation()">TOGGLE NOTATION</button>
        </div>
        <select id="difficulty-select" onchange="setDifficulty(this.value)">
            <option value="1">Level 1 (Easiest)</option>
            <option value="2">Level 2</option>
            <option value="3">Level 3</option>
            <option value="4">Level 4</option>
            <option value="5">Level 5</option>
            <option value="6">Level 6</option>
            <option value="7">Level 7</option>
            <option value="8">Level 8</option>
            <option value="9">Level 9</option>
            <option value="10">Level 10</option>
            <option value="11">Level 11</option>
            <option value="12">Level 12</option>
            <option value="13">Level 13</option>
            <option value="14">Level 14</option>
            <option value="15" selected>Level 15 (Grandmaster 3200)</option>
        </select>
        <select id="side-select" onchange="setPlayerSide(this.value)">
            <option value="w" selected>Play as White</option>
            <option value="b">Play as Black</option>
        </select>
        <div id="error-message"></div>
        <div id="rating-display">Your Rating: 1500</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <script>
    let game, selectedSquare, showNotation, aiDifficulty, isAIThinking, moveStack;
    let playerSide = 'w';
    let playerRating = 1500;
    const transpositionTable = new Map();
    const killerMoves = Array(100).fill(null).map(() => []); // Killer moves per depth
    const historyTable = {}; // History heuristic for move ordering

    const pieceSymbols = {
        'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔',
        'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚'
    };

    const pieceValues = { 'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000 };

    // Opening PSTs
    const pawnPSTOpening = [
        [  0,  0,  0,  0,  0,  0,  0,  0 ],
        [ 50, 50, 50, 50, 50, 50, 50, 50 ],
        [ 10, 10, 20, 30, 30, 20, 10, 10 ],
        [  5,  5, 10, 25, 25, 10,  5,  5 ],
        [  0,  0,  0, 20, 20,  0,  0,  0 ],
        [  5, -5,-10,  0,  0,-10, -5,  5 ],
        [  5, 10, 10,-20,-20, 10, 10,  5 ],
        [  0,  0,  0,  0,  0,  0,  0,  0 ]
    ];

    const knightPSTOpening = [
        [-50,-40,-30,-30,-30,-30,-40,-50],
        [-40,-20,  0,  0,  0,  0,-20,-40],
        [-30,  0, 10, 15, 15, 10,  0,-30],
        [-30,  5, 15, 20, 20, 15,  5,-30],
        [-30,  0, 15, 20, 20, 15,  0,-30],
        [-30,  5, 10, 15, 15, 10,  5,-30],
        [-40,-20,  0,  5,  5,  0,-20,-40],
        [-50,-40,-30,-30,-30,-30,-40,-50]
    ];

    const bishopPSTOpening = [
        [-20,-10,-10,-10,-10,-10,-10,-20],
        [-10,  0,  0,  0,  0,  0,  0,-10],
        [-10,  0,  5, 10, 10,  5,  0,-10],
        [-10,  5,  5, 10, 10,  5,  5,-10],
        [-10,  0, 10, 10, 10, 10,  0,-10],
        [-10, 10, 10, 10, 10, 10, 10,-10],
        [-10,  5,  0,  0,  0,  0,  5,-10],
        [-20,-10,-10,-10,-10,-10,-10,-20]
    ];

    const rookPSTOpening = [
        [  0,  0,  0,  0,  0,  0,  0,  0 ],
        [  5, 10, 10, 10, 10, 10, 10,  5 ],
        [ -5,  0,  0,  0,  0,  0,  0, -5 ],
        [ -5,  0,  0,  0,  0,  0,  0, -5 ],
        [ -5,  0,  0,  0,  0,  0,  0, -5 ],
        [ -5,  0,  0,  0,  0,  0,  0, -5 ],
        [ -5,  0,  0,  0,  0,  0,  0, -5 ],
        [  0,  0,  0,  5,  5,  0,  0,  0 ]
    ];

    const queenPSTOpening = [
        [-20,-10,-10, -5, -5,-10,-10,-20],
        [-10,  0,  0,  0,  0,  0,  0,-10],
        [-10,  0,  5,  5,  5,  5,  0,-10],
        [ -5,  0,  5,  5,  5,  5,  0, -5],
        [  0,  0,  5,  5,  5,  5,  0, -5],
        [-10,  5,  5,  5,  5,  5,  0,-10],
        [-10,  0,  5,  0,  0,  0,  0,-10],
        [-20,-10,-10, -5, -5,-10,-10,-20]
    ];

    const kingPSTOpening = [
        [-30,-40,-40,-50,-50,-40,-40,-30],
        [-30,-40,-40,-50,-50,-40,-40,-30],
        [-30,-40,-40,-50,-50,-40,-40,-30],
        [-30,-40,-40,-50,-50,-40,-40,-30],
        [-20,-30,-30,-40,-40,-30,-30,-20],
        [-10,-20,-20,-20,-20,-20,-20,-10],
        [ 20, 20,  0,  0,  0,  0, 20, 20],
        [ 20, 30, 10,  0,  0, 10, 30, 20]
    ];

    // Endgame PSTs
    const pawnPSTEndgame = [
        [  0,  0,  0,  0,  0,  0,  0,  0 ],
        [ 80, 80, 80, 80, 80, 80, 80, 80 ],
        [ 70, 70, 70, 70, 70, 70, 70, 70 ],
        [ 60, 60, 60, 60, 60, 60, 60, 60 ],
        [ 50, 50, 50, 50, 50, 50, 50, 50 ],
        [ 40, 40, 40, 40, 40, 40, 40, 40 ],
        [ 30, 30, 30, 30, 30, 30, 30, 30 ],
        [  0,  0,  0,  0,  0,  0,  0,  0 ]
    ];

    const knightPSTEndgame = [
        [-50,-40,-30,-30,-30,-30,-40,-50],
        [-40,-20,  0,  0,  0,  0,-20,-40],
        [-30,  0, 10, 15, 15, 10,  0,-30],
        [-30,  5, 15, 20, 20, 15,  5,-30],
        [-30,  0, 15, 20, 20, 15,  0,-30],
        [-30,  5, 10, 15, 15, 10,  5,-30],
        [-40,-20,  0,  5,  5,  0,-20,-40],
        [-50,-40,-30,-30,-30,-30,-40,-50]
    ];

    const bishopPSTEndgame = [
        [-20,-10,-10,-10,-10,-10,-10,-20],
        [-10,  0,  0,  0,  0,  0,  0,-10],
        [-10,  0,  5, 10, 10,  5,  0,-10],
        [-10,  5,  5, 10, 10,  5,  5,-10],
        [-10,  0, 10, 10, 10, 10,  0,-10],
        [-10, 10, 10, 10, 10, 10, 10,-10],
        [-10,  5,  0,  0,  0,  0,  5,-10],
        [-20,-10,-10,-10,-10,-10,-10,-20]
    ];

    const rookPSTEndgame = [
        [  0,  0,  0,  0,  0,  0,  0,  0 ],
        [  5, 10, 10, 10, 10, 10, 10,  5 ],
        [ -5,  0,  0,  0,  0,  0,  0, -5 ],
        [ -5,  0,  0,  0,  0,  0,  0, -5 ],
        [ -5,  0,  0,  0,  0,  0,  0, -5 ],
        [ -5,  0,  0,  0,  0,  0,  0, -5 ],
        [ -5,  0,  0,  0,  0,  0,  0, -5 ],
        [  0,  0,  0,  5,  5,  0,  0,  0 ]
    ];

    const queenPSTEndgame = [
        [-20,-10,-10, -5, -5,-10,-10,-20],
        [-10,  0,  0,  0,  0,  0,  0,-10],
        [-10,  0,  5,  5,  5,  5,  0,-10],
        [ -5,  0,  5,  5,  5,  5,  0, -5],
        [  0,  0,  5,  5,  5,  5,  0, -5],
        [-10,  5,  5,  5,  5,  5,  0,-10],
        [-10,  0,  5,  0,  0,  0,  0,-10],
        [-20,-10,-10, -5, -5,-10,-10,-20]
    ];

    const kingPSTEndgame = [
        [-50,-40,-30,-20,-20,-30,-40,-50],
        [-30,-20,-10,  0,  0,-10,-20,-30],
        [-30,-10, 20, 30, 30, 20,-10,-30],
        [-30,-10, 30, 40, 40, 30,-10,-30],
        [-30,-10, 30, 40, 40, 30,-10,-30],
        [-30,-10, 20, 30, 30, 20,-10,-30],
        [-30,-30,  0,  0,  0,  0,-30,-30],
        [-50,-30,-30,-30,-30,-30,-30,-50]
    ];


    window.onload = function() {
        initGame();
    };

    function initGame() {
        game = new Chess();
        selectedSquare = null;
        showNotation = true;
        aiDifficulty = 5; // Default difficulty
        isAIThinking = false;
        moveStack = [];
        document.getElementById('notation').style.display = showNotation ? 'block' : 'none';
        setDifficulty(aiDifficulty);
        createBoard();
        updateBoard();
        updateStatus();
        if (playerSide === 'b') {
            triggerAIMove();
        }
    }


    function createBoard() {
        const boardDiv = document.getElementById('board');
        boardDiv.innerHTML = ''; // Clear any existing board
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const square = document.createElement('div');
                square.classList.add('square');
                square.id = getSquareID(row, col);
                square.dataset.square = getSquareName(row, col);
                if ((row + col) % 2 === 0) {
                    square.classList.add('light');
                } else {
                    square.classList.add('dark');
                }
                square.addEventListener('click', handleSquareClick);
                boardDiv.appendChild(square);
            }
        }
    }

    function updateBoard() {
        const boardDiv = document.getElementById('board');
        const squares = boardDiv.children;
        let notationHTML = '';

        Array.from(squares).forEach(square => {
            const squareName = square.dataset.square;
            const piece = game.get(squareName);
            square.innerHTML = ''; // Clear previous piece

            if (piece) {
                const pieceSpan = document.createElement('span');
                pieceSpan.classList.add('piece');
                pieceSpan.textContent = pieceSymbols[piece.type.toUpperCase() + piece.color];
                square.appendChild(pieceSpan);
            }
             // Update notation
            if (showNotation) {
                if (squareName.charAt(1) === '1') { // Ranks on the left
                    if (squareName.charAt(0) === 'a') {
                         notationHTML += `<div class='rank-notation'>${squareName.charAt(1)}</div>`;
                    }
                }
                if (squareName.charAt(0) === 'a' && row === 7) { // Files on the bottom
                    notationHTML += `<div class='file-notation'>${squareName.charAt(0).toUpperCase()}</div>`;
                }
            }
        });
         document.getElementById('notation').innerHTML = notationHTML;
    }


    function handleSquareClick(e) {
        if (isAIThinking || game.game_over()) return;

        const square = e.target.closest('.square');
        if (!square) return;

        const squareName = square.dataset.square;

        if (!selectedSquare) {
            if (game.get(squareName) && game.get(squareName).color === playerSide) {
                selectedSquare = squareName;
                highlightMoves(selectedSquare);
            }
        } else {
            const move = { from: selectedSquare, to: squareName, promotion: 'q' };
            const legalMoves = game.moves({ square: selectedSquare, verbose: true }).map(m => m.to);

            if (legalMoves.includes(squareName)) {
                makeMove(move);
                clearHighlights();
                selectedSquare = null;
                updateBoard();
                updateStatus();

                if (!game.game_over() && game.turn() !== playerSide) {
                    triggerAIMove();
                }
            } else {
                clearHighlights();
                selectedSquare = null;
                if (game.get(squareName) && game.get(squareName).color === playerSide) {
                    selectedSquare = squareName;
                    highlightMoves(selectedSquare);
                }
            }
        }
    }


    function highlightMoves(pos) {
        clearHighlights();
        const possibleMoves = game.moves({ square: pos });
        if (possibleMoves.length > 0) {
            document.getElementById(getIDFromSquare(pos)).classList.add('selected');
            possibleMoves.forEach(move => {
                document.getElementById(getIDFromSquare(move)).classList.add('highlighted');
            });
        }
    }

    function clearHighlights() {
        document.querySelectorAll('.square').forEach(square => {
            square.classList.remove('selected', 'highlighted');
        });
    }


    function setDifficulty(level) {
        aiDifficulty = parseInt(level);
        document.getElementById('difficulty-select').value = level;
    }


    function evaluateBoard(tempGame) {
        let score = 0;
        const board = tempGame.board();
        const isEndgame = tempGame.history().length > 40; //Rough endgame detection

        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const piece = board[row][col];
                if (piece) {
                    let pstValue = 0;
                    const pst = getPST(piece.type, isEndgame);
                    const pstRow = piece.color === 'w' ? 7 - row : row; //Invert row for white pieces
                    const pstCol = col;

                    pstValue = pst[pstRow][pstCol];


                    if (piece.color === 'w') {
                        score += pieceValues[piece.type] + pstValue;
                    } else {
                        score -= pieceValues[piece.type] + pstValue;
                    }
                }
            }
        }

        // Additional heuristics
        score += mobility(tempGame, 'w') - mobility(tempGame, 'b');
        score += checkmateScore(tempGame, 'w') - checkmateScore(tempGame, 'b');

        return score;
    }

    function getPST(pieceType, isEndgame) {
        if (isEndgame) {
            switch (pieceType) {
                case 'p': return pawnPSTEndgame;
                case 'n': return knightPSTEndgame;
                case 'b': return bishopPSTEndgame;
                case 'r': return rookPSTEndgame;
                case 'q': return queenPSTEndgame;
                case 'k': return kingPSTEndgame;
            }
        } else {
            switch (pieceType) {
                case 'p': return pawnPSTOpening;
                case 'n': return knightPSTOpening;
                case 'b': return bishopPSTOpening;
                case 'r': return rookPSTOpening;
                case 'q': return queenPSTOpening;
                case 'k': return kingPSTOpening;
            }
        }
        return Array(8).fill(null).map(() => Array(8).fill(0)); // Default PST
    }


    function mobility(tempGame, color) {
        const moves = tempGame.moves({ verbose: true });
        let mobilityScore = 0;
        for (const move of moves) {
            if (move.color === color) {
                mobilityScore++;
            }
        }
        return color === 'w' ? mobilityScore * 2 : -mobilityScore * 2; //Slightly weight mobility
    }

    function checkmateScore(tempGame, color) {
        return tempGame.in_checkmate() && tempGame.turn() !== color ? 100000 : 0;
    }


    function orderMoves(moves, depth) {
        const scores = {};
        moves.forEach(move => {
            scores[move.san] = 0;

            // Capture ordering
            if (move.captured) {
                scores[move.san] += 10000; //Captures are generally good

                //Material gain from capture
                scores[move.san] += pieceValues[move.captured];
                scores[move.san] -= pieceValues[move.piece];
            }

            // Promotion ordering
            if (move.promotion === 'q') {
                scores[move.san] += 9000; //Promoting to queen is very good
            }

            // Killer move heuristic
            if (killerMoves[depth] && killerMoves[depth].includes(move.san)) {
                scores[move.san] += 7000; //Killer moves are good
            }

             // History heuristic
            if (historyTable[move.san]) {
                scores[move.san] += historyTable[move.san];
            }


            // Center control (Slightly encourage center moves in opening)
            const centerSquares = ['c4', 'd4', 'e4', 'f4', 'c5', 'd5', 'e5', 'f5', 'c3', 'd3', 'e3', 'f3', 'c6', 'd6', 'e6', 'f6'];
            if (depth > 4 && !move.captured && centerSquares.includes(move.to)) {
                 scores[move.san] += 300;
            }


        });

        moves.sort((a, b) => scores[b.san] - scores[a.san]); //Sort in descending order

        return moves;
    }


    function quiescence(tempGame, alpha, beta, maximizingPlayer) {
        let stand_pat = evaluateBoard(tempGame);
        if (stand_pat >= beta) return beta;
        if (alpha < stand_pat) alpha = stand_pat;

        const captureMoves = tempGame.moves({ verbose: true }).filter(move => move.captured);

        captureMoves.sort((a, b) => { //Simple capture ordering in quiescence
            let scoreA = pieceValues[a.captured] - pieceValues[a.piece];
            let scoreB = pieceValues[b.captured] - pieceValues[b.piece];
            return scoreB - scoreA; // Descending order (good captures first)
        });


        for (const move of captureMoves) {
            const newGame = new Chess(tempGame.fen());
            newGame.move(move);

            let score = -quiescence(newGame, -beta, -alpha, !maximizingPlayer);
            if (score >= beta) return beta;
            if (score > alpha) alpha = score;
        }
        return alpha;
    }


    function negamax(tempGame, depth, alpha, beta, color, startTime, timeLimit, isPV = false) {
        const fen = tempGame.fen();
        if (transpositionTable.has(fen) && transpositionTable.get(fen).depth >= depth) {
            return transpositionTable.get(fen).score * color;
        }

        if (depth === 0 || tempGame.game_over() || (Date.now() - startTime > timeLimit)) {
            const score = quiescence(tempGame, alpha, beta, color === 1) * color;
            transpositionTable.set(fen, { score: score * color, depth: 0 });
            return score;
        }

        let bestScore = -Infinity;
        let bestMove = null;
        const moves = orderMoves(tempGame.moves({ verbose: true }), depth);
        if (moves.length === 0) return tempGame.in_check() ? -200000 + depth : 0;

        for (let i = 0; i < moves.length; i++) {
            const move = moves[i];
            const newGame = new Chess(tempGame.fen());
            newGame.move(move);
            let score;

            if (i === 0 && isPV) {
                score = -negamax(newGame, depth - 1, -beta, -alpha, -color, startTime, timeLimit, true);
            } else {
                score = -negamax(newGame, depth - 1, -alpha - 1, -alpha, -color, startTime, timeLimit, false);
                if (alpha < score && score < beta) {
                    score = -negamax(newGame, depth - 1, -beta, -alpha, -color, startTime, timeLimit, true);
                }
            }

            if (Date.now() - startTime > timeLimit) break;

            if (score >= beta) {
                if (!move.captured && !move.promotion) {
                    killerMoves[depth].push(move.san);
                    historyTable[move.san] = (historyTable[move.san] || 0) + depth * depth;
                }
                transpositionTable.set(fen, { score: beta * color, depth });
                return beta;
            }
            if (score > bestScore) {
                bestScore = score;
                bestMove = move;
                alpha = Math.max(alpha, score);
            }
        }
        transpositionTable.set(fen, { score: bestScore * color, depth });
        return bestScore;
    }


    function getBestMove(tempGame, level) {
        const moves = orderMoves(tempGame.moves({ verbose: true }), 0);
        if (moves.length === 0) {
            console.log("No legal moves available");
            return null;
        }

        const startTime = Date.now();
        const timeLimit = level === 15 ? 15000 : 3000; // 15 seconds for level 15, increased from 3 seconds
        const maxDepth = level === 15 ? 8 : Math.min(level, 6); // Increased depth to 8 for level 15, from 6

        let bestMove = moves[0];
        let bestScore = -Infinity;
        const color = tempGame.turn() === 'w' ? 1 : -1;

        console.log(`Starting search for depth ${maxDepth}, time limit ${timeLimit}ms`);

        for (let depth = 1; depth <= maxDepth; depth++) {
            let alpha = -Infinity;
            let beta = Infinity;
            let currentBestMove = bestMove;

            for (const move of moves) {
                const newGame = new Chess(tempGame.fen());
                newGame.move(move);
                const score = -negamax(newGame, depth - 1, -beta, -alpha, -color, startTime, timeLimit, true);
                if (Date.now() - startTime > timeLimit) break;
                if (score > bestScore) {
                    bestScore = score;
                    currentBestMove = move;
                    alpha = score;
                }
            }

            if (Date.now() - startTime <= timeLimit) {
                bestMove = currentBestMove;
                console.log(`Depth ${depth} completed, best move: ${bestMove.san}, score: ${bestScore}`);
            } else {
                console.log(`Time limit exceeded at depth ${depth}`);
                break;
            }
        }


        // Avoid repetition
        if (moveStack.length >= 4) {
            const lastMoves = moveStack.slice(-4).map(m => m.san);
            const moveCounts = {};
            lastMoves.forEach(m => moveCounts[m] = (moveCounts[m] || 0) + 1);
            if (moveCounts[bestMove.san] >= 2) {
                console.log("Avoiding repetition");
                const nonRepetitiveMoves = moves.filter(move => move.san !== bestMove.san);
                if (nonRepetitiveMoves.length > 0) {
                    bestMove = nonRepetitiveMoves[0]; // Choose another move if available
                }
            }
        }


        if (level < 15) {
            const topMoves = moves.slice(0, Math.max(1, Math.round(16 - (level * 0.8)))); // Reduced randomness
            bestMove = topMoves[Math.floor(Math.random() * topMoves.length)];
            console.log(`Lower level random move: ${bestMove.san}`);
        }


        console.log(`Final move selected: ${bestMove.san}`);
        return bestMove;
    }


    async function triggerAIMove() {
        if (isAIThinking || game.game_over() || game.turn() === playerSide) return;

        isAIThinking = true;
        updateStatus();

        console.log("AI is thinking...");
        const level = parseInt(aiDifficulty);
        const bestMove = await Promise.resolve(getBestMove(new Chess(game.fen()), level)); //Use a promise to avoid blocking UI

        if (bestMove) {
            makeMove(bestMove);
            updateBoard();
            updateStatus();
            checkGameOver();
        } else {
            console.log("AI could not determine a move.");
        }

        isAIThinking = false;
        updateStatus();
    }


    function makeMove(move) {
        try {
            const result = game.move(move);
            if (result) {
                moveStack.push(result); // Store move in move stack
                updateNotationDisplay();
                checkGameOver();
            } else {
                showError("Invalid move");
            }
        } catch (e) {
            showError("Invalid move format");
        }
    }


    function checkGameOver() {
        if (game.in_checkmate()) {
            const winner = game.turn() === 'w' ? 'Black' : 'White';
            updateRating(winner === playerSide[0].toUpperCase() ? 'win' : 'lose');
            return true;
        } else if (game.in_draw() || game.in_stalemate() || game.in_threefold_repetition()) {
            updateRating('draw');
            return true;
        }
        return false;
    }


    let ratingTimeout;
    function updateRating(outcome) {
        const ratingDisplay = document.getElementById('rating-display');
        let ratingChange = 0;

        if (outcome === 'win') {
            ratingChange = Math.round(Math.random() * 15) + 5; // 5-20 points for win
            playerRating += ratingChange;
            ratingDisplay.textContent = `Rating: ${playerRating} (+${ratingChange})`;
        } else if (outcome === 'lose') {
            ratingChange = -(Math.round(Math.random() * 15) + 5); // -5 to -20 points for loss
            playerRating += ratingChange;
            ratingDisplay.textContent = `Rating: ${playerRating} (${ratingChange})`;
        } else if (outcome === 'draw') {
            ratingDisplay.textContent = `Rating: ${playerRating} (Draw)`;
        }

        clearTimeout(ratingTimeout);
        ratingTimeout = setTimeout(() => {
            ratingDisplay.textContent = `Rating: ${playerRating}`; // Revert to base rating after delay
        }, 3000); // Clear message after 3 seconds
    }


    function newGame() {
        initGame();
        moveStack = [];
        updateNotationDisplay();
        clearError();
    }

    function undoMove() {
        if (isAIThinking) return;
        game.undo();
        moveStack.pop(); // Remove last move from stack
        updateBoard();
        updateStatus();
        updateNotationDisplay();
        clearError();
    }


    function toggleNotation() {
        showNotation = !showNotation;
        document.getElementById('notation').style.display = showNotation ? 'block' : 'none';
        updateBoard(); //Re-render notation
    }


    function updateStatus() {
        let status = '';
        if (game.in_checkmate()) {
            status = 'Checkmate! ' + (game.turn() === 'w' ? 'Black wins' : 'White wins');
        } else if (game.in_draw() || game.in_stalemate() || game.in_threefold_repetition()) {
            status = 'Draw';
        } else {
            status = (game.turn() === 'w' ? 'White to move' : 'Black to move');
            if (game.in_check()) {
                status += ', ' + (game.turn() === 'w' ? 'White is in check' : 'Black is in check');
            }
        }

        if (isAIThinking) {
            status = 'AI is thinking...';
        }
        document.getElementById('status').textContent = status;
    }


    function setPlayerSide(side) {
        playerSide = side;
        const playerSideButton = document.getElementById('player-side-button');
        playerSideButton.textContent = `Play as ${side === 'w' ? 'White' : 'Black'}`;
        newGame(); //Restart game with new side
    }


    function showError(message) {
        document.getElementById('error-message').textContent = message;
        document.getElementById('error-message').style.display = 'block';
    }

    function clearError() {
        document.getElementById('error-message').textContent = '';
        document.getElementById('error-message').style.display = 'none';
    }


    // --- Utility Functions ---
    function getSquareID(row, col) {
        return 'square-' + getSquareName(row, col);
    }

    function getSquareName(row, col) {
        const files = 'abcdefgh';
        const rank = 8 - row;
        const file = files.charAt(col);
        return file + rank;
    }

    function getIDFromSquare(square) {
        return 'square-' + square;
    }

    function updateNotationDisplay() {
        if (!showNotation) return;
        const notationDiv = document.getElementById('notation-moves');
        notationDiv.innerHTML = ''; // Clear existing notation

        let notationHTML = '';
        for (let i = 0; i < moveStack.length; i += 2) {
            const whiteMove = moveStack[i];
            const blackMove = moveStack[i + 1];
            notationHTML += `<div class='move-pair'>`;
            notationHTML += `<span class='move white'>${whiteMove.san}</span>`;
            if (blackMove) {
                notationHTML += `<span class='move black'>${blackMove.san}</span>`;
            }
            notationHTML += `</div>`;
        }
        notationDiv.innerHTML = notationHTML;
        notationDiv.scrollTop = notationDiv.scrollHeight; // Scroll to bottom
    }


</script>
</body>
</html>
